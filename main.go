package main

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"strconv"
	"strings"

	"github.com/sigurn/crc16"
)

type AutoGenerated []struct {
	Directory string `json:"directory"`
	Items     []struct {
		TitleEN      string         `json:"titleEN"`
		TitlePL      string         `json:"titlePL"`
		Registers    []string       `json:"registers"`
		DomoticzIdx  int            `json:"DomoticzIdx"`
		OptionRanges []OptionRanges `json:"optionRanges"`
		Ratio        float64        `json:"ratio"`
		Unit         string         `json:"unit"`
		Graph        int            `json:"graph"`
		MetricType   string         `json:"metric_type"`
		MetricName   string         `json:"metric_name"`
		LabelName    string         `json:"label_name"`
		LabelValue   string         `json:"label_value"`
	} `json:"items"`
}

type OptionRanges struct {
	Key     int    `json:"key"`
	ValueEN string `json:"valueEN"`
	ValuePL string `json:"valuePL"`
}

type OutputData struct {
	Key   string
	Value string
}

const (
	inverterSerial      = 519690751
	register_start1 int = 0x0000
	register_end1   int = 0x0027
	register_start2 int = 0x0105
	register_end2   int = 0x0114
)

func main() {
	// con, err := net.Dial("tcp", "10.81.150.6:8899")
	con, err := net.Dial("tcp", "localhost:8899")
	checkErr(err)

	defer con.Close()

	value := []OutputData{}

	value = append(value, sendAndProcess(register_start1, register_end1, con)...)
	value = append(value, sendAndProcess(register_start2, register_end2, con)...)

	b, err := json.Marshal(value)
	checkErr(err)

	fmt.Println(string(b))
}

func readJSONfile(filename string) AutoGenerated {
	data := AutoGenerated{}

	file, err := ioutil.ReadFile(filename)
	checkErr(err)

	err = json.Unmarshal([]byte(file), &data)
	checkErr(err)
	return data
}

func sendAndProcess(register_start, register_end int, con net.Conn) []OutputData {
	msg := createMsg(inverterSerial, register_start, register_end)
	fmt.Printf("Data send: % X\n", msg)

	data := readJSONfile("data.json")

	_, err := con.Write([]byte(msg))
	checkErr(err)

	reply := make([]byte, 128)

	_, err = con.Read(reply)
	checkErr(err)

	fmt.Printf("% X\n", reply)

	return printAllData(reply, register_start, register_end, data)
}

func createMsg(inverterSerial, register_start, register_end int) []byte {
	start := "A5"         // # start A5
	length := "1700"      // # datalength
	controlcode := "1045" // # controlCode
	serial := "0000"      // # serial

	hexInverterSerial := strconv.FormatInt(int64(inverterSerial), 16)
	inverter_sn2, err := hex.DecodeString(hexInverterSerial[6:8] + hexInverterSerial[4:6] + hexInverterSerial[2:4] + hexInverterSerial[0:2])
	checkErr(err)

	datafield, _ := hex.DecodeString("020000000000000000000000000000")

	pos_ini := Zfill(strconv.FormatInt(int64(register_start), 16), 4)[1:3]
	pos_fin := Zfill(strconv.FormatInt(int64(register_end-register_start+1), 16), 4)[2:4]

	businessfield, _ := hex.DecodeString("0103" + Zfill(pos_ini, 4) + Zfill(pos_fin, 4))

	a := Zfill(fmt.Sprintf("%X", crc16.Checksum(businessfield, crc16.MakeTable(crc16.CRC16_MODBUS))), 4)
	crc, _ := hex.DecodeString(a[2:4] + a[0:2]) // Swap the fields

	endCode, _ := hex.DecodeString("15")

	msg, _ := hex.DecodeString(start + length + controlcode + serial)
	msg = append(msg, inverter_sn2...)
	msg = append(msg, datafield...)
	msg = append(msg, businessfield...)
	msg = append(msg, crc...)

	// Checksum is calculated by the sum of all bytes, than leave only the last byte as result
	var checksum uint64
	for i := 1; i < len(msg); i++ {
		checksum += uint64(msg[i])
	}

	msg = append(msg, byte(checksum&0xff))
	msg = append(msg, endCode...)

	return msg
}

func printAllData(reply []byte, register_start, register_end int, data AutoGenerated) []OutputData {
	returnValue := []OutputData{}
	item := OutputData{}
	for i := 0; i < (register_end-register_start)*2; i++ {
		for x := range data {
			for y := range data[x].Items {
				for z := range data[x].Items[y].Registers {
					if data[x].Items[y].Registers[z] == fmt.Sprintf("0x%04X", register_start+i) {
						// OptionRanges can be contain multiple adresses
						if len(data[x].Items[y].OptionRanges) == 0 {
							fmt.Printf("0x%04X - %v: %.2f%v\n",
								register_start+i,
								data[x].Items[y].TitleEN,
								float64(getValue(i*2, reply))*data[x].Items[y].Ratio,
								data[x].Items[y].Unit)

							item.Key = data[x].Items[y].TitleEN
							item.Value = fmt.Sprintf("%f", float64(getValue(i*2, reply))*data[x].Items[y].Ratio)

						} else {
							fmt.Printf("0x%04X - %v: %v\n",
								register_start+i,
								data[x].Items[y].TitleEN,
								data[x].Items[y].OptionRanges[getValue(i*2, reply)].ValueEN)
							item.Key = data[x].Items[y].TitleEN
							item.Value = data[x].Items[y].OptionRanges[getValue(i*2, reply)].ValueEN
						}
						returnValue = append(returnValue, item)
					}
				}
			}
		}
	}
	return returnValue
}

func Zfill(s string, overall int) string {
	l := overall - len(s)
	return strings.Repeat("0", l) + s
}

// getValue get part of []byte
// s is start position
// As values alway exist of two bytes this is set fixed
func getValue(s int, data []byte) int64 {
	r := ""
	s += 28 // Always start at 28th byte
	if len(data) >= s+2 {
		for i := s; i < s+2; i++ {
			r = r + fmt.Sprintf("%v", strconv.FormatInt(int64(data[i]), 16))
		}
	}
	output, _ := strconv.ParseInt(r, 16, 64)
	return output
}

func checkErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
